<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[链表的基本操作]]></title>
    <url>%2F2019%2F02%2F17%2F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言设链表的存储结构如下： 12345typedef struct Node&#123;Type data; //数据域；Type: 用户定义数据类型struct Node *next; //指针域&#125; Node, *LinkList; 实现链表的基本操作（增删查改、创建、翻转、获取链表长度、销毁链表等）。 具体实现1、创建链表123456789101112131415161718Node *create(int a[], int len)//创建链表&#123; Node *head = nullptr, *tail = nullptr, *tmp = nullptr;//从表尾插入数据 for (int i = 0; i &lt; len; i++) &#123; tmp = new Node; tmp-&gt;data = a[i]; tmp-&gt;next = nullptr; if (head == nullptr)&#123;//判断表是否为空 head = tail = tmp; &#125; else&#123; tail-&gt;next = tmp; tail = tmp; &#125; &#125; return head;&#125; 2、插入数据1234567891011121314151617181920void insert(LinkList &amp;L, int i, int value)//在第i个位置的前面插入一个元素&#123; int num = 1; LinkList p = L; LinkList s = new Node; s-&gt;data = value; if (i == 1)&#123;//在头节点前插入 s-&gt;next = L; L = s; &#125; else&#123; while (num &lt; i - 1 &amp;&amp; p) &#123; num++; p = p-&gt;next; &#125; s-&gt;next = p-&gt;next; p-&gt;next = s; &#125;&#125; 插入一个节点主要思路即找到要插入位置的上一个节点，头节点需特殊处理 3、删除数据123456789101112131415161718192021void deleteitem(LinkList &amp;L, int i, int &amp;elem)//删除第i个位置的元素,传址考虑可能删除头节点&#123; int num = 1; Node *p = L; Node *tmp = nullptr; if (i == 1)&#123;//删除头节点 tmp = L; L = L-&gt;next; delete tmp; &#125; else&#123; while (num &lt; i - 1 &amp;&amp; p) &#123; num++; p = p-&gt;next; &#125; tmp = p-&gt;next; p-&gt;next = tmp-&gt;next; delete tmp; &#125;&#125; 删除某个节点主要思路即找到要删除节点的上一个节点，头节点需特殊处理 4、获取第i个位置的数据值1234567891011void getelem(LinkList L, int i, int &amp;elem)//获取第i个位置上的元素&#123; LinkList p = L; int num = 1; while (num &lt; i&amp;&amp;p != NULL) &#123; num++; p = p-&gt;next; &#125; elem = p-&gt;data;&#125; 5、获取链表长度12345678910int Listlength(LinkList L)//获得链表的长度&#123; int num = 0; LinkList p = L; while (p)&#123; num++; p = p-&gt;next; &#125; return num;&#125; 6、输出链表全部数据123456789void printu(LinkList L)&#123; LinkList p = L; while(p)&#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 7、翻转链表大概有三种方法可以实现翻转链表 使用3个指针（p，q，r）遍历单链表，逐个链节点进行反转p，q使得两个节点之间转向，r记录剩下节点的开头节点 p=head; q=head-&gt;next; head-&gt;next=nullptr; 接下来的操作可用循环解决r=q-&gt;next; q-&gt;next=p;此时实现两个节点的转向了 ​ 再更新p，q即可 代码： 12345678910111213141516void reverse(LinkList &amp;L)//翻转链表&#123; if (L == nullptr) return;//只有一个节点没必要翻转 Node *p, *q, *r; p = L; q = L-&gt;next; L-&gt;next = nullptr;//旧的头指针，翻转后为尾指针，故next指向nullptr while (q)&#123; r = q-&gt;next; q-&gt;next = p; p = q; q = r; &#125; L = p;//更新头节点&#125; 从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，最后将第一个节点挪到新表的表尾。 如图所示： 代码： 123456789101112131415void reverse_1(LinkList &amp;L)&#123; Node *p, *q; if (L-&gt;next == nullptr) return; p = L-&gt;next; while (p-&gt;next)&#123; q = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next = L-&gt;next; L-&gt;next = q; &#125; p-&gt;next = L; L = L-&gt;next; p-&gt;next-&gt;next = nullptr;&#125; 递归 循环模拟的递归 代码： 1234567void reverse_2(LinkList &amp;L, LinkList p, LinkList p1)//递归,用循环模拟的&#123; if (p1 == nullptr)&#123; L-&gt;next = nullptr; L = p; return; &#125; LinkList p2 = p1-&gt;next; p1-&gt;next = p; reverse_2(L, p1, p2);&#125; 纯粹的递归 代码： 123456789LinkList reverse_3(LinkList &amp;L)//纯粹的递归&#123; if (L == nullptr || L-&gt;next == nullptr) //链表为空或递归终点 return L; Node *newhead = reverse_3(L-&gt;next);//递归到链尾 L-&gt;next-&gt;next = L; L-&gt;next = nullptr; return newhead;&#125; 8、摧毁链表12345678910void destorylist(LinkList L)//摧毁线性表&#123; LinkList p = L, tmp; while (p) &#123; tmp = p; p = p-&gt;next; delete tmp; &#125;&#125; 9、测试结果 注意在创建链表，将数组当作形参传入函数时。 在main()函数里该句能够准确测出该整型数组的长度，但在该图中结果为1。查阅了相关资料：在ANSI C标准中明文规定“在函数参数的声明中，数组名当作指向该数组第一个元素的指针”。故此时sizeof(a)测得其实是一个指针变量的字节数。另外，当用数组名作函数参数时，形参数组就可以从实参数组那里得到起始地址后，形参数组就和实参数组共占同一段内存单元，从而在调用函数期间，如果改变了形参数组的值，也就该变了实参数组的值。]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门教程]]></title>
    <url>%2F2019%2F02%2F17%2FMarkdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[斜体和粗体代码： 1234*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果： 斜体或_斜体_粗体加粗斜体删除线 分级标题代码： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果就是字体逐渐变小，一级最大，依此递减。 超链接形式：[链接文字](链接地址 &quot;链接标题&quot;) 代码： 12不会请[百度](https://www.baidu.com)不会请[百度](https://www.baidu.com "百度") 显示效果： 不会请百度不会请百度 这里设置了标题，当鼠标指针放在超链接上时会显示标题 自动链接一般用来处理网址和电子邮件信箱。用&lt;&gt;包起来即可。 代码： 12&lt;https://www.baidu.com&gt;&lt;1234567@qq.com&gt; 显示效果： https://www.baidu.com&#49;&#x32;&#x33;&#x34;&#53;&#54;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d; 插入图像形式：![图片Alt](图片地址 &quot;图片Title&quot;) 其中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的。 代码： 1![迪丽热巴](Markdown入门教程/1.jpg "迪丽热巴") 显示效果： 引用形式：在被引用的文字前面加&gt;符号 代码： 12&gt; 无意义的占行文字1.&gt; 无意义的占行文字2. 显示效果： 无意义的占行文字1.无意义的占行文字2. 列表有序列表代码： 1231. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 显示效果： 有序列表项 一 有序列表项 二 有序列表项 三 无序列表代码： 123- 无序列表项 一- 无序列表项 二- 无序列表项 三 显示效果： 无序列表项 一 无序列表项 二 无序列表项 三 其中-可以用*或+代替 包含引用的列表形式：如果要在列表项目内放进引用，那 &gt; 就需要缩进 代码： 1234- 引用类型 &gt; 引用1 &gt; 引用2 &gt; 引用3 显示效果： 引用类型 引用1引用2引用3 分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线 代码： 12345* * *********- - ---------------------------------------- 代码块一种利用缩进（Tab），一种用三个`将代码块包括。两种方式效果一样。 行内式代码： 1c++中函数`cin()`怎么用 显示效果： c++中函数cin()怎么用]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
