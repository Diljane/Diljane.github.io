<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2019%2F02%2F22%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言本文适合已经有一门高级语言基础的同学观看，字不多，大部分把语法以代码的方式呈现。 print功能 print(1) 输出：1 print(“……”/‘……’) 输出：…… print(‘I’m a boy) 报错，正解如下： print(“I’m a boy”)用双引号保住句子 用单引号包住句子，在‘号前面加上转义字符 print(‘age’+’18’) 输出：age18 print(‘age’+18) 报错，正解如下： print(‘age’+’18’) print(‘age’+str(18)) print(1+1) 输出：2 print(‘1’+1) 报错，正解如下： print(int(‘1’)+1) 输出：2 print(int(‘1.1’)+1) 报错，int()只能转化整数，不能转化小数。正解如下： print(float(‘1.1’)+1) 输出：2.1 print(1,2,3) 自动带空格分隔，输出1 2 3 print(‘a:’,1,’b’,2) 输出：a: 1 b: 2 print自动带换行回车 取消换行print(……，end=””)即可。end=”……”……即输出后跟着的东西。print(1,end=”“)输出”1\“ 运算符号 python中的加(+)、减(-)、乘(*)、取余(%)和c/c++中符号意义相同，而python中的除(/)不是整除，整除为”//“ print(5/3) 输出：1.6666666666666667 平方符号。2的平方即为2**2 print(3**2) 输出3的平方：9 print(2**4) 输出2的四次方：16 python不支持自增，即i++。支持i+=1。 变量python中不需要int a = ……;直接赋值即可 a = 1, str = “abc”等 同时赋值多个变量：a,b,c=1,2,3(print(a,b,c) = “1 2 3”) 循环1、while循环1234flag = 1while flag &lt; 100: print(flag) flag += 1 while循环体内的东西为加了tab的 2、for循环123456789l1 = [1,2,3,4,5,6]for i in l1: print(i)#######################for i in range(1,10) print(i)## 输出1到9range(start,stop,步长)## start若未声明默认值为0for i in range(1,10,2) print(i)## 输出1，3，5，7，9 条件语句1、if语句1234567x = 1y = 2z = 3if x &lt; y &lt; z: print("yes")## 可以识别出想要表达的意思，即x小于y且y小于zif x = y: print("yes")## 报错，判断相等需要"==" 2、if else语句1234567x = 1y = 2z = 3if x &lt; y &lt; z: print("yes")else: print("no") 3、if elif else语句123456789x = 1y = 2z = 3if x &lt; 1: print("yes")elif x == 1: print("a")else: print("no") 第一次满足elif条件后就会直接跳出if语句执行后面的语句(当然满足了一条if语句不会跳出整个if语句)，elif语句可以不止一条。可以只有if和elif。 4、break和continue与c/c++中用法相同函数定义函数要以def开头。 1、定义函数12345678910def func(a,b): c = a * b print(c)func(1,2)## 输出2def func1(a,b): print(a)func1(1,2)## 输出1func1(b=1,a=2)## 输出2func1(1,)## 报错 2、函数默认参数1234567891011121314def func(name,age,sex,height): print('name:',name, 'age:',age, 'sex:',sex, 'height:',height)func(1,1,1,1)## 输出name: 1 age: 1 sex: 1 height: 1def func(name,age = 1,sex = 1,height = 1):func(1)## 输出name: 1 age: 1 sex: 1 height: 1def func(name,age = 1,sex,height = 1):func(1,age = 2,1)## 报错，没有被提前定义的值sex不能在调用时放在已经定义过的值age后面改为func(1,1,age = 2)即可 3、函数返回值12345def func(): a = 10 print(a) return a+10print(func())## 输出10\n20 全局变量和局部变量全局变量一般每个字母都是大写 1234567X = 10def func(): a = 10print(X)## 输出10func()print(a)## 报错 1234567a = Nonedef func1(): a = 20print(a)## 输出Nonefunc1()print(a)## 输出None 12345678a = Nonedef func1(): global a## 声明为全局变量a a = 20print(a)## 输出Nonefunc1()print(a)## 输出20 文件操作1、w(write)、r(read)方式处理文件12345678text = "hello"my_file = open('my_file.txt','w')## 若没有my_file.txt这个文件会创建一个该文件，该文件可在与.py文件同目录下找到(若未指定路## 径)## w-write(写东西进文件，若文件内有字符会将字符清掉再写字符进去)## r-read(读取文件)my_file.write(text)my_file.close()## 记得关闭文件，不然可能会宕机 2、a(append:追加)方式处理文件12345append_text = " world!"my_file = open('my_file.txt','a')## 若没有my_file.txt这个文件会创建一个该文件，该文件可在与.py文件同目录下找到(若未指定路## 径)，此时效果等同于wmy_file.write(append_text)my_file.close()## 记得关闭文件，不然可能会宕机 3、r(read)方式读文件123456file = open('my_file.txt','a')## 还可读取excel文件，也是按行读取content = file.read()## 文件全部内容都读取出来## file.readline()读取文件的一行## file.readlines()读取全部文件字符，并存放在列表里面，每一行为列表里的一个元素print(content)file.close() readlines()用法示例 输出：[&#39;hello world!\n&#39;, &#39;zhangyu\n&#39;, &#39;helan\n&#39;, &#39;China&#39;] r+：可读写 wb：二进制写 rb：二进制读 12with open("1.txt",'w') as file: file.write('hello!')## 不用担心file.close()问题 class 类定义类名第一个字母一般是大写 1、定义类12345678910111213class Calculator: name = 'Good!' price = 100## 属性 def add(self,a,b):## 必须带self，不带报错 print(self.name) print(a+b) def minus(self,a,b): print(a-b)calcul = Calculator()## 实例化print(calcul.name)## 输出Good！calcul.add(1,2) ## 输出Good!\n3calcul.minus(2,1)## 输出1 2、class init 功能123456789class Calculator: def __init__(self,name,price,height,width):## 注意init前两个下划线 self.name=name self.price=price self.h=height self.w=widthcalcul = Calculator('Bad',10,5,5)print(calcul.name,calcul.price,calcul.h,calcul.w)## 输出：Bad 10 5 5 123456789class Calculator: name = 'Good!' price = 100## 固有属性 def __init__(self,height,width): self.h=height self.w=widthcalcul = Calculator(5,5)print(calcul.name,calcul.price,calcul.h,calcul.w)## 输出：Good! 100 5 5 还可以给变量赋予初始化值，像def一个函数一样 def __init__(self,name,price,height = 5,width = 5): 输入 input12a_input = input('please input a string:')## return stringprint('This string is:',a_input) 例如： 12a_input = int(input('please input a number:'))print('This number is:',a_input) 元组(tuple)和列表(list)一连串有顺序的数字 1、元祖和列表形式1234567a_tuple = (12,2,3,4,5)another_tuple = 2,4,6,8a_list=[12,3,2,4,5] 0 1 2 3 4## 和c/c++类似 -5 -4-3-2-1len(a_list)## 求长度，可以当作一维数组用 可以for循环逐个输出其中的元素 2、列表的一些功能12345678910111213141516171819202122a=[1,2,3,4]a.append(5)## 在列表的最后加上元素5print(a)## 输出：[1, 2, 3, 4, 5]a.insert(1,0)## 在a[1]前面插入元素0print(a)## 输出：[1, 0, 2, 3, 4]a.remove(2)## 删除列表中第一次出现的2，后面出现的2不会删除print(a)##输出：[1,3,4]print(a[-1])## 输出4print(a[0:3])## 输出[1,2,3],不会输出索引位于3的那项print(a[3:])## 输出[4],即索引3(包括3)之后的项print(a[-3:])## 输出[2,3,4],即索引-3之后的项print(a.index(2))## 返回值为2的第一次出现的索引，输出：1print(a.count(2))## 返回列表中出现2的次数，输出：1a.sort()## 从小到大排序，并且会将原列表覆盖掉a.sort(reverse=True)## 从大到小排序，因为原来默认reverse=False 3、多维列表123456a=[1,2,3,4,5]multi_a=[[1,2,3],[2,3,4],[3,4,5]]print(a[1])## 输出2print(multi_a[0][1])## 输出2## 类似c/c++多维数组 字典赋予key和value。(类似c++中map模板)。 123456789a=&#123;'apple':1,'banana':2,'orange':3&#125;print(a['apple'])## 输出1del a['apple']## 删除apple元素print(a)## 输出：&#123;'banana': 2, 'orange': 3&#125;a['pear']=4print(a)## 输出：&#123;'apple': 1, 'banana': 2, 'orange': 3, 'pear': 4&#125; 123a=&#123;'apple':[1,2,3],'banana':2,'pear':&#123;'a':1,'b':2&#125;&#125;print(a['pear']['b'])## 输出：2print(a['apple'][0])## 输出：1 载入模块 import1、载入内置模块12345import time## import time as t## 给time取一个别名t，因为有的模块名字特别长，打起来很麻烦print(time.localtime())## 输出：time.struct_time(tm_year=2019, tm_mon=2, tm_mday=22, tm_hour=15, tm_min=59, tm_sec=28, tm_wday=4, tm_yday=53, tm_isdst=0) 123from time import time,localtime## 从time模块引用time和localtime功能print(localtime()) 12from time import *## 从time模块引用所有功能 2、载入自己写的模块假定项目中有两个.py文件，分别为1.py，2.py。若想在2.py中调用1.py模块，只需保证两个文件在同目录下即可。 然后就是正常的调用 123## 2.pyimport 11.printdata()## printdata()为1.py文件中的一个函数 错误处理123456try: file=open('abcd.txt','r')except Exception as e:## 把错误信息存放在e中 print(e)else:## 若没有错误信息则执行else部分 …… zip、lambda、map1、zip1234567891011121314a=[1,2,3]b=[4,5,6]zip(a,b)## 将a,b竖向的连起来，单纯这样调用会返回一个功能## 可视化list(zip(a,b))## 输出[(1,4),(2,5),(3,6)]for i,j in zip(a,b): print(i/2,j*2)## 输出：0.5 81.0 101.5 12list(zip(a,a,b))## 输出[(1,1,4),(2,2,5),(3,3,6)] 2、lambda1234567def func1(a,b): return(a+b)print(func1(1,1))## 输出2## lambdafunc2=lambda x,y:x+yprint(func2(1,1))## 输出2 3、mapmap就是把一个功能和参数绑定起来 12345map(func1,[1],[2])## 代表要传入的参数a为1，b为2，传入参数要放在列表中## 返回一个功能：&lt;map object at 0x1056a5438&gt;list(map(func1,[1],[2])## 输出[3] list(map(func1,[1,2],[2,4]))## 输出[3,8] 浅复制(copy)和深复制(deep copy)1、引用1234567a=[11,2,3]b=a## b和a指向同一内存地址，改变a，那么b也随之改变## 测试print(id(a)==id(b))## id()返回变量在内存中的地址，输出Truec=copy.copy(a)print(id(a)==id(c))## 输出False，此时改变a并不会改变c 2、浅copy1234567891011import copya=[1,2,[1,2]]d=copy.copy(a)print(id(a)==id(d))## 输出Falseprint(id(a[2])==id(d[2]))## 输出Truea[0]=11print(d)## 输出[1,2,[1,2]],改变a[0]并不会改变da[2][0]=11print(d)## 输出[1,2,[11,2]]，此时会发生改变 可以理解为copy()是打包带走第一层数据(第二层数据还是公用的) 3、deepcopy12345import copya=[1,2,[1,2]]d=copy.deepcopy(a)print(id(a)==id(d))## 输出Falseprint(id(a[2])==id(d[2]))## 输出False deepcopy()打包带走所有的数据 set123456789101112131415161718l1=[1,1,2,2,3,3,4,4]print(set(l1))## 输出：&#123;1, 2, 3, 4&#125;str='hello'print(set(str))## 输出：&#123;'o', 'l', 'h', 'e'&#125;print(set([l1,str]))## 报错tmp=set(str)tmp.add('a')print(tmp)## 输出：&#123;'o', 'h', 'l', 'e', 'a'&#125;tmp.add('h')print(tmp)## 输出：&#123;'h', 'l', 'e', 'o'&#125;tmp.add(['a','b'])## 报错tmp.clear()print(tmp)## 输出：set() 1234567str='hello'tmp=set(str)print(tmp.remove('h'))## 输出：Noneprint(tmp)## 输出：&#123;'e', 'l', 'o'&#125;print(tmp.remove('a'))## 报错print(tmp.discard('a'))## 不报错，其也能删除集合中的元素 一般没有返回值的函数，print(func())出来回时None 12345678set1=&#123;1,2,3&#125;set2=&#123;2,3,4&#125;print(set1.difference(set2))## 输出：&#123;1&#125;## 差集，即为set1中有而set2中没有的东西print(set1.intersection(set2))## 输出：&#123;2，3&#125;## 交集 正则表达式正则表达式(Regular Expression，又称RegEx)，是用来匹配字符串的一种工具。爬取网页时常用。 1、简单的匹配12345pattern1='apple'pattern2='banana'str='apple is fruit'print(pattern1 in str)## 输出：Trueprint(pattern2 in str)## 输出：False 使用正则表达式则需要调用一个python的内置模块re。 如果 re.search() 找到了结果, 它会返回一个 match 的 object。 如果没有匹配到, 它会返回 None。 1234567import repattern1='apple'pattern2='banana'str='apple is fruit'print(re.search(pattern1, str))## 输出：&lt;_sre.SRE_Match object; span=(0, 5), match='apple'&gt;print(re.search(pattern2, str))## 输出：None 2、高级的匹配匹配多种可能，使用[]需要找到多个可能性的字符串，用[]将可能的字符包裹起来。比如[ab]表示要找的字符可以是a或b，在”……“的前面加上r表示这是一个正则表达式，不加则是一个普通的字符串。 12345import repattern1=r'[Aa]pple'str='apple is fruit'print(re.search(pattern1, str))## 输出：&lt;_sre.SRE_Match object; span=(0, 5), match='apple'&gt; 正则表达式查询表 不一一举例。 注意re.search()只会返回第一次匹配到的结果 多行匹配如果一个字符串有很多行，我们想用^来匹配开头字符。 如果想匹配的字符是在第二行的开头，用r&quot;^I&quot;是匹配不到的。这时候要使用 另外一个参数, 让 re.search() 可以对每一行单独处理. 这个参数就是 flags=re.M或者 flags=re.MULTILINE。 1234567str="""apple is fruit.I'm handsome."""print(re.search(r"^I", string))## 输出：Noneprint(re.search(r"^I", string, flags=re.M)) ## 输出：&lt;_sre.SRE_Match object; span=(17, 18), match='I'&gt; group 组可以使用()为匹配到的内容分组。通过分组，我们可以定位匹配到的内容。 例如： 123456import rematch=re.search(r'(\d+),bir:(.+)','Id:1234,bir:10:22')print(match.group())## 输出：1234,bir:10:22print(match.group(1))## 输出：1234print(match.group(2))## 输出：10：22 当group很时，可以给每个组起个名字，形如：?P&lt;name&gt;，然后用名字就可以找到这个组了。注意P一定要大写。 123456import rematch=re.search(r'(?P&lt;Id&gt;\d+),bir:(?P&lt;bir&gt;.+)','Id:1234,bir:10:22')print(match.group())## 输出：1234,bir:10:22print(match.group('Id'))## 输出：1234print(match.group('bir'))## 输出：10：22 寻找所有的匹配项findall()findall可以找到所有的匹配项，然后返回一个列表。 1234import reprint(re.findall(r'a[bc]e','abe ace ade'))## 输出：['abe', 'ace']print(re.findall(r'a(b|c)e','abe ace ade'))## 输出：['b', 'c'] 替换字符串sub()re.sub()函数，比string.replace()更加灵活。 1print(re.sub(r'a[bc]d','123','abd 456'))## 输出：123 456 分割split()re.split()函数，比普通split()函数分割的更加灵活。返回一个列表。 12print(re.split(r'[,;. ]','a;b c.d,e'))## 意思是碰到[]里面的字符都进行分割## 输出：['a', 'b', 'c', 'd', 'e'] compile123com1=re.compile(r'a[bc]d')print(com1.search('abd 123'))## 输出：&lt;_sre.SRE_Match object; span=(0, 3), match='abd'&gt;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表的基本操作]]></title>
    <url>%2F2019%2F02%2F17%2F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言设链表的存储结构如下： 12345typedef struct Node&#123;Type data; //数据域；Type: 用户定义数据类型struct Node *next; //指针域&#125; Node, *LinkList; 实现链表的基本操作（增删查改、创建、翻转、获取链表长度、销毁链表等）。 具体实现1、创建链表123456789101112131415161718Node *create(int a[], int len)//创建链表&#123; Node *head = nullptr, *tail = nullptr, *tmp = nullptr;//从表尾插入数据 for (int i = 0; i &lt; len; i++) &#123; tmp = new Node; tmp-&gt;data = a[i]; tmp-&gt;next = nullptr; if (head == nullptr)&#123;//判断表是否为空 head = tail = tmp; &#125; else&#123; tail-&gt;next = tmp; tail = tmp; &#125; &#125; return head;&#125; 2、插入数据1234567891011121314151617181920void insert(LinkList &amp;L, int i, int value)//在第i个位置的前面插入一个元素&#123; int num = 1; LinkList p = L; LinkList s = new Node; s-&gt;data = value; if (i == 1)&#123;//在头节点前插入 s-&gt;next = L; L = s; &#125; else&#123; while (num &lt; i - 1 &amp;&amp; p) &#123; num++; p = p-&gt;next; &#125; s-&gt;next = p-&gt;next; p-&gt;next = s; &#125;&#125; 插入一个节点主要思路即找到要插入位置的上一个节点，头节点需特殊处理 3、删除数据123456789101112131415161718192021void deleteitem(LinkList &amp;L, int i, int &amp;elem)//删除第i个位置的元素,传址考虑可能删除头节点&#123; int num = 1; Node *p = L; Node *tmp = nullptr; if (i == 1)&#123;//删除头节点 tmp = L; L = L-&gt;next; delete tmp; &#125; else&#123; while (num &lt; i - 1 &amp;&amp; p) &#123; num++; p = p-&gt;next; &#125; tmp = p-&gt;next; p-&gt;next = tmp-&gt;next; delete tmp; &#125;&#125; 删除某个节点主要思路即找到要删除节点的上一个节点，头节点需特殊处理 4、获取第i个位置的数据值1234567891011void getelem(LinkList L, int i, int &amp;elem)//获取第i个位置上的元素&#123; LinkList p = L; int num = 1; while (num &lt; i&amp;&amp;p != NULL) &#123; num++; p = p-&gt;next; &#125; elem = p-&gt;data;&#125; 5、获取链表长度12345678910int Listlength(LinkList L)//获得链表的长度&#123; int num = 0; LinkList p = L; while (p)&#123; num++; p = p-&gt;next; &#125; return num;&#125; 6、输出链表全部数据123456789void printu(LinkList L)&#123; LinkList p = L; while(p)&#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125; 7、翻转链表大概有三种方法可以实现翻转链表 使用3个指针（p，q，r）遍历单链表，逐个链节点进行反转p，q使得两个节点之间转向，r记录剩下节点的开头节点 p=head; q=head-&gt;next; head-&gt;next=nullptr; 接下来的操作可用循环解决r=q-&gt;next; q-&gt;next=p;此时实现两个节点的转向了 ​ 再更新p，q即可 代码： 12345678910111213141516void reverse(LinkList &amp;L)//翻转链表&#123; if (L == nullptr) return;//只有一个节点没必要翻转 Node *p, *q, *r; p = L; q = L-&gt;next; L-&gt;next = nullptr;//旧的头指针，翻转后为尾指针，故next指向nullptr while (q)&#123; r = q-&gt;next; q-&gt;next = p; p = q; q = r; &#125; L = p;//更新头节点&#125; 从第2个节点到第N个节点，依次逐节点插入到第1个节点(head节点)之后，最后将第一个节点挪到新表的表尾。 如图所示： 代码： 123456789101112131415void reverse_1(LinkList &amp;L)&#123; Node *p, *q; if (L-&gt;next == nullptr) return; p = L-&gt;next; while (p-&gt;next)&#123; q = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next = L-&gt;next; L-&gt;next = q; &#125; p-&gt;next = L; L = L-&gt;next; p-&gt;next-&gt;next = nullptr;&#125; 递归 循环模拟的递归 代码： 1234567void reverse_2(LinkList &amp;L, LinkList p, LinkList p1)//递归,用循环模拟的&#123; if (p1 == nullptr)&#123; L-&gt;next = nullptr; L = p; return; &#125; LinkList p2 = p1-&gt;next; p1-&gt;next = p; reverse_2(L, p1, p2);&#125; 纯粹的递归 代码： 123456789LinkList reverse_3(LinkList &amp;L)//纯粹的递归&#123; if (L == nullptr || L-&gt;next == nullptr) //链表为空或递归终点 return L; Node *newhead = reverse_3(L-&gt;next);//递归到链尾 L-&gt;next-&gt;next = L; L-&gt;next = nullptr; return newhead;&#125; 8、摧毁链表12345678910void destorylist(LinkList L)//摧毁线性表&#123; LinkList p = L, tmp; while (p) &#123; tmp = p; p = p-&gt;next; delete tmp; &#125;&#125; 9、测试结果 注意在创建链表，将数组当作形参传入函数时。 在main()函数里该句能够准确测出该整型数组的长度，但在该图中结果为1。查阅了相关资料：在ANSI C标准中明文规定“在函数参数的声明中，数组名当作指向该数组第一个元素的指针”。故此时sizeof(a)测得其实是一个指针变量的字节数。另外，当用数组名作函数参数时，形参数组就可以从实参数组那里得到起始地址后，形参数组就和实参数组共占同一段内存单元，从而在调用函数期间，如果改变了形参数组的值，也就该变了实参数组的值。]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门教程]]></title>
    <url>%2F2019%2F02%2F17%2FMarkdown%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[斜体和粗体代码： 1234*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果： 斜体或_斜体_粗体加粗斜体删除线 分级标题代码： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果就是字体逐渐变小，一级最大，依此递减。 超链接形式：[链接文字](链接地址 &quot;链接标题&quot;) 代码： 12不会请[百度](https://www.baidu.com)不会请[百度](https://www.baidu.com "百度") 显示效果： 不会请百度不会请百度 这里设置了标题，当鼠标指针放在超链接上时会显示标题 自动链接一般用来处理网址和电子邮件信箱。用&lt;&gt;包起来即可。 代码： 12&lt;https://www.baidu.com&gt;&lt;1234567@qq.com&gt; 显示效果： https://www.baidu.com&#49;&#50;&#x33;&#52;&#53;&#54;&#55;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#x6d; 插入图像形式：![图片Alt](图片地址 &quot;图片Title&quot;) 其中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的。 代码： 1![迪丽热巴](Markdown入门教程/1.jpg "迪丽热巴") 显示效果： 引用形式：在被引用的文字前面加&gt;符号 代码： 12&gt; 无意义的占行文字1.&gt; 无意义的占行文字2. 显示效果： 无意义的占行文字1.无意义的占行文字2. 列表有序列表代码： 1231. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 显示效果： 有序列表项 一 有序列表项 二 有序列表项 三 无序列表代码： 123- 无序列表项 一- 无序列表项 二- 无序列表项 三 显示效果： 无序列表项 一 无序列表项 二 无序列表项 三 其中-可以用*或+代替 包含引用的列表形式：如果要在列表项目内放进引用，那 &gt; 就需要缩进 代码： 1234- 引用类型 &gt; 引用1 &gt; 引用2 &gt; 引用3 显示效果： 引用类型 引用1引用2引用3 分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线 代码： 12345* * *********- - ---------------------------------------- 代码块一种利用缩进（Tab），一种用三个`将代码块包括。两种方式效果一样。 行内式代码： 1c++中函数`cin()`怎么用 显示效果： c++中函数cin()怎么用]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
